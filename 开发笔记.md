  

# 前端

## 22.4.5-4.7

### 表单

#### 表单域

就是一个包含表单元素的区域

使用<form>

标签定义

```html
<form action='action.php' method='POST'>
    
</form>
```

#### 表单元素

在表单域可以定义各种表单元素 

##### input

```html
<input type='属性值'>
```

| text     | 定义单行的输入字段                 |
| -------- | ---------------------------------- |
| password | 其中的字段会以星号代替             |
| radio    | 单选按钮                           |
| checkbox | 复选框                             |
| submit   | 提交按钮，会把表单数据提交到服务器 |
| image    | 图像形式的提交按钮                 |



  

| 属性      | 值      | 描述                                              |
| --------- | ------- | ------------------------------------------------- |
| name      | 自定义  | 定义input元素名称，单选按钮和复选框要有相同的name |
| value     | 自定义  | 表单默认值 或该元素显示的值                       |
| maxlength | 正整数  | 输入字符的最大长度                                |
| checked   | checked | 默认被选中                                        |

#### label标签

 用于给input元素定义标签，当点击label标签内文本时，焦点会自动转移到对应元素 

```html
<label for="username"> 用户名 </label> <input id="username" type="text" name="username">
```

#### 下拉表单

```html
<body>
    <form>
        <select name='name'>
            <option>A</option>
            <option>B</option>
            <option>c</option>
        </select>
    </form>
</body>
```

![image-20220407201216463](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220407201216463-16493335375082.png)

### 元素显示模式

#### 块级元素

特点

- 自己独占一行

- 高度，宽度以及内边距都可以控制

- 默认宽度是父元素的100%

- 是一个容器和盒子 可以放行内或者块级元素

  

注意

- p里不能放div

#### 行内元素

特点

- 一行可以显示多个

- 无法直接设置高度宽度

- 默认宽度就是本身内容宽度

- 行内元素只能容纳文本或其他行内元素

  

注意

- 特色情况下a里面可以放块级元素

#### 行内块元素

行内元素有几个特殊元素 img input td

它们同时具有块元素和行内元素的特点

#### 元素显示模式转换

```css
    a {
        background-color: blanchedalmond;
        display: block;
        width: 200px;
        height: 200px;
    }
```

![image-20220407204533466](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220407204533466-16493355343403.png)

```css
div {
    display:inline
}
```

![image-20220407205100795](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220407205100795-16493358617094.png)

## 22.4.9

### 盒子模型

页面布局有三大核心

- 盒子模型
- 浮动
- 定位

#### 边框

- border-width 边框宽度
- border-style 边框样式 **不常用**
- border-color 边框颜色

#### 外边距

可用于实现水平居中

- 块级

```css
    #ui {
        background-color: pink;
        margin:0 auto; //左右设置auto即可
        width: 50%;
        height: 200px;

    }
    body {
        margin:0 0 0 0;
    }
```

![image-20220412085443126](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220412085443126-16497248840851.png)

- 行内/行内块

  

```css
 <div id="ui"></div>
</body>
<style>
    body {
        text-align: center;
        width:100%;
        height:100%
    }
    #ui {
        display: inline-block;
        background-color: pink;
        margin-top:500px;
        width: 60%;
        height:500px;
    }
```

![image-20220412094519736](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220412094519736-16497279208882.png)

#### 外边距塌陷

对于两个嵌套关系的块元素，父元素有上外边距，子元素也有上外边距，此时父元素会塌陷较大的外边距值 

解决方法

- 为父元素定义上边框
- 为父元素定义内边距
- 为父元素添加overflow:hidden

#### 清除内外边距

```css
* {
    margin: 0;
    padding:0;
}
```

效果![image-20220412101709847](%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/image-20220412101709847-16497298314013-16497299298294.png)

行内元素尽量只设置左右边距

## 22.4.12-14

### 圆角和阴影

#### 圆角边框

```css
    #root {
        width: 300px;
        height:150px;
        background-color: pink;
        border-radius: 9px;
    }
```

![image-20220412132428883](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220412132428883-16497410698355.png)

#### 盒子阴影

| 值       | 描述                   |
| -------- | ---------------------- |
| h-shadow | 必须，水平阴影的位置   |
| v-shadow | 必须，垂直阴影的位置   |
| blur     | 模糊距离               |
| spread   | 阴影尺寸               |
| color    | 颜色                   |
| inset    | 将外部阴影改为内部阴影 |

- 阴影不会占用空间

### 浮动布局

CSS提供了三种传统布局（移动端有更多布局方法）方式

- 普通流（按默认规定好的默认方式排列）
- 浮动 
- 单位

浮动可以改变元素标签默认排列

网页布局第一准则：

- 多个行内元素排列找文档流
- 多个块级元素纵向排列找浮动

float属性用于创建浮动框 将其移到一边 直到左边缘或右边缘碰到另一个浮动框的边缘

语法

```css
body {
    float: left //只有两个取值 left和right
}
```

#### 浮动的特性

加了浮动的元素会具有很多特征

- 会脱离标准流
- 浮动的盒子不再保留原先位置  
- 浮动元素具有行内块元素特点 所以行内元素有了浮动 不需要转换
- 浮动的盒子没有空隙

#### 搭配父元素标准流使用

为了约束元素位置，网页布局一般采取的策略是：**先用标准流的父元素排列上下位置，内部子元素采取浮动**

如果盒内无法容纳下子元素，子元素会向下

```html
<body>
<div id="root">
    <div id="left-bar">
        <a class="bar-link">手机</a>
        <a class="bar-link">电脑</a>
        <a class="bar-link">路由器</a>
        <a class="bar-link">路由器</a>
        <a class="bar-link">路由器</a>
        <a class="bar-link">路由器</a>
        <a class="bar-link">路由器</a>
        <a class="bar-link">路由器</a>
        <a class="bar-link">路由器</a>
        <a class="bar-link">路由器</a>
    </div>
    <img src="https://cdn.cnbj1.fds.api.mi-img.com/mi-mall/8e169482b8cbf7a68daaef1464881446.jpg?w=2452&h=920" alt="" id="pic">
</div>
</body>
<style>
#root {
    width:1226px;
    height:460px;
    margin:auto;
}
#left-bar {
    width: 234px;
    height: 460px;
    background-color: rgb(147,151,155);
    float:left;
}
.bar-link {
    text-align: center;
    width:234px;
    height: 42px;
    display: block;
}
.bar-link:hover {
    background-color: rgb(255,103,0);
}
#pic {
    float:left;
    width: 992px;
    height: 460px;
}

</style>
```

![image-20220413134707654](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220413134707654-16498288285366.png)

注意

- 如果一个盒子浮动了，其他兄弟盒子也应该浮动，以免引起问题
- 浮动的盒子只会影响盒子后面的标准流，不会影响盒子前面的

#### 清除浮动

 父盒子在很多情况下不方便给高度，但是子盒子又不占有位置，

最后父盒子高度为0，影响下面的标准流盒子。

**本质就是清除浮动元素造成的影响**

清除浮动之后，父盒子就会根据浮动的盒子自动检测高度

语法：

```css
.selector {
    clear:both
}
```

| 属性值 | 描述                 |
| ------ | -------------------- |
| left   | 不允许左侧有浮动元素 |
| right  | 不允许右侧有浮动元素 |
| both   | 同时清除两侧浮动影响 |

清除浮动方法

- 额外标签法 也是w3c推荐做法

  在浮动元素末尾添加一个空标签

  ```html
  <div style='clear:both'></div>
  ```

- 父元素添加overflow属性

  ```css
  #root {
      overflow:hidden
  }
  ```

  缺点：会将溢出的元素隐藏

- 父元素添加after伪元素

  ```css
   
  ```

  

- 父元素添加双伪元素

## 22.4.15

### 定位

部分情况，标准流和浮动都无法实现，需要定位

浮动可以让多个块级盒子在一行显示，经常用于横向排列盒子

定位则是让盒子自由地在盒子内移动位置或固定在屏幕某个位置

并且可以压住其他盒子

#### 定位组成

定位，是将盒子定在一个位置，所有定位也是在摆盒子

定位=定位模式+边偏移

- 定位模式

  决定元素的定位方式，通过css属性position设置

  | 值       | 语义     |
  | -------- | -------- |
  | static   | 静态定位 |
  | relative | 相对定位 |
  | absolute | 绝对定位 |
  | fixed    | 固定定位 |

- 边偏移就是定位的盒子移动到的最终位置，

  有

  | 边偏移属性 | 示例        | 描述                             |
  | ---------- | ----------- | -------------------------------- |
  | top        | top:80px    | 定义元素相对于父元素上边线的距离 |
  | bottom     | bottom:80px | 定义元素相对于父元素下边线的距离 |
  | left       | left:80px   | 定义元素相对于父元素左边线的距离 |
  | right      | right:80px  | 定义元素相对于父元素右边线的距离 |

  top，bottom，left，right四个属性

  

#### 四种定位模式

##### 静态定位（static）

是元素默认定位方式，无定位的意思

##### 相对定位（relative）

相对定位是元素在移动位置的时候，是相对于自身而言的，元素移动后，原来的位置仍保留。

![image-20220414220357595](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220414220357595-16499450386851.png)

```css
    #root{
        width: 200px;
        height:200px;
        background-color: green;
        position: relative;
        top: 200px;
    }
```

![image-20220414220820357](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220414220820357-16499453012382.png)

##### 绝对定位

绝对定位在移动位置时，是相对于祖先元素的

特点

- 如果没有祖先元素或**祖先元素没有定位**，就相对于浏览器
- 如果祖先元素

##### 固定定位

```css
element {
    position:fixed;
}
```

特点

- 和父元素没有任何关系
- 不随滚动条滚动
- 不占用原先位置

## 22.4.16

### 定位叠放次序

使用盒z-index来控制盒子的先后次序

语法

```css
select {
    z-index:1;
}
```

- 数值可以正整数 负整数或0，默认auto，数值越大盒子越靠上
- 如果属性相同，则按照书写顺序，后来居上
- 数值后不能加单位
- **只有定位的盒子才有这个属性**

```css
    .a {
        z-index:5;
        background-color: red;
    }
    .b {
        z-index:6;
        background-color: green;
    }
    .c {
        background-color: blue;
    }
```



![image-20220416153920752](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220416153920752-16500947618551.png)

### 定位盒子的水平居中

加了绝对定位的盒子不能用margin-auto实现水平居中，但可以通过算法实现水平和垂直居中

水平：

- 1. left走父元素宽度的一半
  2. margin-left：-width/2

垂直：

- 1. top：50%
  2. margin-top: -width/2

![image-20220416155239183](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220416155239183-16500955601602.png)

```css
    .box {
        width: 200px;
        height: 200px;
        background-color: green;
        position: absolute;
        //margin:auto;
        top:50%;
        margin-top:-100px;
        left:50%;
        margin-left:-100px;
    }
```

### 定位的特殊属性

- 浮动的元素不会压住下面标准流的文字
- 绝对定位会压住下面标准流的所有内容

## 22.4.20

### 垂直居中

vertical-align：baseline | top | middle | bottom

## 22.4.21

### 过渡

是一个简单动画，由一个状态过渡成另一个状态

```css
transition: 要过渡的属性 | 花费时间 | 运动曲线 | 何时开始
```

- 属性：想要变化的css属性
- 花费时间：必填，单位为秒
- 运动曲线
- 何时开始

```css
        div {
            width: 200px;
            height: 200px;
            background-color: pink;
            transition: width 1s;
        }
        div:hover {
            width: 400px;
        }
```

## 22.4.22

### CSS3新增选择器

#### 属性选择器

可以根据元素的特定属性选择元素

```css
input[value] {
    //表示选择有value属性的input元素
}
input[value=123] {
    //表示选择有value属性 且属性值为123的input元素
}
input[value*=123] {
    //表示选择有value属性 且属性值包含123的input元素
}
```

#### 结构伪类选择器

主要根据文档结构来选择元素

| 选择符        | 简介                 |
| ------------- | -------------------- |
| E:first:child | 该元素的第一个子元素 |
| E:last-child  | 该元素的最后一个元   |

#### 伪元素

通过css直接插入html标签

| 选择符   | 简介 |
| -------- | ---- |
| ::before |      |
| ::after  |      |

- 创建的元素属于行内元素
- 新建的的元素在文档中是找不到的
- before和after必须有content属性
- before在父元素内容前创建元素
- after在父元素内容后创建元素

### 转换

是css3中具有颠覆性的特征之一

可以简单理解为变形

可以：

- 移动
- 旋转
- 缩放

#### 移动

```css
transform: translate(x,y)
transform:translateX()
transform:translateY()
```

- 优点：不会影响其他元素的位置
- 对行内元素没有影响

##### 让盒子水平居中

```css
transform:translate(-50%,-50%)
```

对行内元素无效

## 22.4.26

### 动画

#### 定义

```css
@keyframes name {
    0% {
        
    }
    100% {
        
    }
}
div {
    animation-name:name;
    animation-duration: time
}
```

- 0%是动画的开始，100%是动画的结束
- 

## 22.5.14


### flex布局

flex，意为弹性布局，用来为盒子模型提供最大的灵活度，任何一个盒子都可以指定为flex布局

- 当父盒子设为flex布局后，子元素的flot,clear,vertical0algin将失效

  

采用了flex布局的元素，成为flex容器，它的所有子元素自动成为容器成员，成为flex项目

#### flex父元素常见属性

- flex-direction：设置主轴的方向
- justify-content：设置主轴上的子元素排列方式
- flex-warp：设置子元素是否换行

##### flex-direction

在flex布局中，分主轴和侧轴两个方向，默认主轴是x轴方向，水平向右，侧轴是y轴方向，水平向下

![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//img20220514220530.png)

flex-direction属性决定主轴的方向（即项目的排列方向）

| 属性           | 描述             |
| -------------- | ---------------- |
| row            | 默认值，从左到右 |
| row-reverse    | 从右到左         |
| column         | 从上到下         |
| column-reverse | 从上到下         |

![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//img20220514223104.png)

```css
    div {
        display: flex;
        flex-direction: row;
        justify-content: space-around;
        align-items: center;
        width: 400px;
        background-color: aqua;
        height: 300px;
        flex-direction: row-reverse;
    }
    span {
        width: 100px;
        height: 100px;
        background-color: pink;
    }
```

##### justify-content

这个属性设置主轴上子元素排列方式

| 属性          | 描述                                         |
| ------------- | -------------------------------------------- |
| flex-start    | 默认值，从头部开始 如果主轴是x轴，则从左到右 |
| flex-end      | 从尾部开始排列                               |
| center        | 在主轴居中对齐（如果主轴是x轴则水平居中）    |
| space-around  | 平分剩余空间                                 |
| space-between | 先两边贴边在平分剩余空间                     |

```css
    div {
        display: flex;
        align-items: center;
        width: 400px;
        background-color: aqua;
        height: 300px;
        justify-content: space-between;
    }
```

![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//img20220515102137.png)

##### flex-warp

默认情况下，flex会将子元素在父元素的一行内显示，若显示不下，则缩小子元素大小

| 属性   | 描述           |
| ------ | -------------- |
| nowarp | 不换行，默认值 |
| warp   | 换行           |

![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/20220515103721.png)

![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/20220515103759.png)

##### align-items

用来设置侧轴的方向（单行）

```css
    div {
        display: flex;
        align-items: center;
        width: 600px;
        background-color: aqua;
        height: 300px;
        justify-content: center;
        flex-wrap: wrap;

    }
    span {
        width: 100px;
        height: 100px;
        background-color: pink;
    }
```

设置水平垂直居中

![image-20220519201339854](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20220519201339854.png)

##### align-content

设置多行子元素排列方式

```css
    div {
        display: flex;
        align-items: center;
        width: 750px;
        background-color: aqua;
        height: 500px;
        justify-content: center;
        flex-wrap: wrap;
        align-content: center;
        

    }
    span {
        width: 170px;
        height: 150px;
        background-color: pink;
    }
```

![image-20220519212304664](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20220519212304664.png)

##### flex-flow

是flex-direction和flex-warp的复合写法

> flex-flow : row warp

#### flex子元素的属性

- flex子项目占用的份数
- align-self 控制子项自己在侧轴的排列方式
- order定义子项的排列属性

# JavaScript

## 22.4.16

### 数组

数组是一组数据的集合，优雅地存在一种变量下

#### 创建

```js
var arr = new Array();

var arr = ['A','B','C']
```

#### 排序

```javascript
const a = [8,5,2,1,4,5,6,2,1,4,5,6,3,2,1,4,7,854,5236,155,5]
for (let i = 0; i<a.length-1;i++){
    for (let j = 0;j<a.length-i-1;j++){
        if (a[j]>a[j+1]){
            let t
            t = a[j]
            a[j] = a[j+1]
            a[j+1] =t
        }
    }
}
for (let i = 0; i<a.length;i++) {
    console.log(a[i])
}

```

![image-20220416172152531](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220416172152531-16501009134443.png)

## 22.4.17

### DOM修改表单属性

利用DOM可以修改表单的如下属性

- value
- type
- disabled
- checked
-  selected

```js
    const btn = document.getElementById("btn");
    const input = document.getElementById("form");
    btn.onclick = () => {
        input.value = "456"
    }
```

### 修改样式属性

我们可以通过JS修改元素的大小，颜色，位置等样式

- element.style
- element.className

```js
    const div = document.getElementById("area");
    div.onclick = () => {
        div.style.backgroundColor ='green';
    }
```

### 元素焦点事件

- onFocus 得到焦点
- onblur 失去焦点

```javascript
    const text = document.getElementById("text");
    text.onfocus =() => {
        text.value = ''
    }
    text.onblur =() => {
        text.value = '手机'
    }
```

### 使用className修改元素样式

提现在css写好样式，当需要修改时，修改元素的类名即可

### 节点

- 利用父子兄节点关系获取元素
- 兼容性稍差

网页中所有内容都是节点（标签，属性，文本）

所有HTML元素（节点）都可通过JS 创建，修改，删除

#### 获取子节点

- element.childNodes 它会返回所有节点，包括文本节点，不推荐使用
- element.children 返回元素节点

#### 获取第一个子元素

- firstElementChild返回第一个子元素，找不到则返回null
- lastElementChild返回最后一个子元素
- element.children[n-1]

#### 兄弟节点

- element.nextSibling  下一个兄弟节点 返回所有类型节点
- element.previousSibling  上一个兄弟节点 返回所有类型节点
- element.nextElementSlibling 下一个元素节点
- element.previousElementSlibling 上一个元素节点

#### 添加和创建节点

- 创建：doccument.createElement()

- 添加：node.appendChild() 添加到父元素的子元素末尾
- 添加到父元素最前面：node.insertBefore()

案例

```css
    const input = document.getElementById("input");
    const btn = document.getElementById("btn");
    btn.onclick = () => {
        const ele = document.createElement("p")
        ele.innerHTML = input.value;
        const area = document.querySelector('#review')
        area.insertBefore(ele,area[area.length - 1])
        input.value = ''

    }
```

#### 删除子节点

node.removeChild

### 复制节点

- node.clone 返回该节点的一个副本，浅拷贝
- node.clone(true) 复制节点里的子节点，深拷贝

#### 三种动态创建元素的方式

- document.write
- element.innerHTML
- document.createElement

## 22.4.18

### 事件注册

注册事件有两种方式：传统方式和方法监听注册方式

- 传统方式：

  注册事件的唯一性，同一个元素同一个事件只能设置一个处理函数

- 方法监听注册方式

  - W3C推荐方法

  - addEventListener()是一个方法

  - 同一个元素同一个事件可以添加多个处理函数

使用方法：element.addEventListener(type , listener , useCapture)

参数：

- type: 事件类型的字符串，比如click mouseover
- listener：事件处理函数
- useCapture 可选参数

### 事件删除

- 设置element.onclick=null
- element.removeEventLIstener()参数与注册事件相同

### DOM事件流

事件流描述的时从页面接收事件的属性

事件发生时会在元素节点之间按特点顺序传播，这个传播过程就是DOM事件流

### 事件对象

- event就是一个事件对象，写在监听函数的参数里
- 事件对象只有在有了事件才会存在，它是由系统自动创建的，不需要手动传参
- 事件对象时事件一系列数据的集合



### 阻止默认事件

e.preventDefault()

```javascript
    const ele= document.getElementById("area")
    ele.addEventListener('click', function(e){
        e.preventDefault();
    })
```

### 阻止冒泡

element.stopPropagation

### 事件委托

也称事件代理，在jQuery成为事件委派

原理：不是给每个子节点单独设置监听器，而是设置在父节点上，利用冒泡原理影响每个子节点

### 鼠标事件

#### 获取鼠标位置

| 属性      | 说明                        |
| --------- | --------------------------- |
| e.clientX | 相对于浏览器可视窗口的x坐标 |
| e.clienty | 相对于浏览器可视窗口的y坐标 |
| e.screenX | 相对于屏幕                  |
| e.screenY | 相对于屏幕                  |

案例

```html
<html>
    <body>
        <img src="https://s3.bmp.ovh/imgs/2022/04/18/b91cab775474005b.jpg"" alt="">
        <script>
            var ele = document.querySelector('img')
            document.addEventListener("mousemove", function(event) {
                
                ele.style.left = event.clientX + "px"
                ele.style.top = event.clientY + "px"
            })

        </script>
    </body>
    <style>
        img {
            position: absolute;
        }
    </style>
</html>
```

：图片跟随鼠标移动

### 键盘事件

| 名称       | 描述                                 |
| ---------- | ------------------------------------ |
| onkeyup    | 被松开是触发                         |
| onkeydown  | 被按下时触发                         |
| onkeypress | 被按下时触发，但不识别功能键，如ctrl |

keyCode:返回该键的ASCII值

案例：按下S获得焦点

```css
<html>
    <body>
        <input type="text" id="input" placeholder="Enter a number">
        <script>
            document.querySelector('html').addEventListener('keyup', function(e) {
                if(e.keyCode === 83) {
                    console.log('S was pressed');
                    document.querySelector('#input').focus();
            }
        })

        </script>
    </body>
</html>
```

案例：当输入数字时上方加大字体显示文本框内容，文本框为空时隐藏上方盒子

```html
<html>
    <body>
        <p id="box"></p>
        <input type="text" id="input" placeholder="Enter a number">
        <script>
            var input = document.getElementById("input");
            var box = document.getElementById("box");
            input.addEventListener("keyup", function(){
                if(input.value ==""){
                    box.style.display='none'
                }
                box.style.display='block'
                box.innerText = input.value;
                console.log(input.value);
                console.log(box.innerText);
            })
        </script>
        <style>
            #box{
                font-size: large;
            }
        </style>
    </body>
</html>
```

## 22.4.19 

### windows常用事件

- 窗口加载事件：windows.onload(),可用于将js文件放在任何地方
- DOMContectLoaded 当DOM加载完成时（不包括图片，样式）
- windows.onresize 当浏览器窗口大小发生变化

### 定时器

案例：短信验证码发送页面

```html
<html>
    <body>
        <input type="text" id="input" placeholder="Enter Your Phone Number">
        <button>发送</button>
        <script>
            var input = document.getElementById('input');
            var button = document.querySelector('button');
            button.onclick = function () {
                input.value = '';
                input.disabled = true;
                button.disabled = true;
                var total = 10;
                var timer = setInterval(function () {
                    button.innerText = '还有' + total-- + '秒可再次发送';
                }, 1000);
                if(total<=0){
                    clearInterval(timer);
                    button.innerText = '重新发送';
                }
            }

        </script>
        <style>
        </style>
    </body>
</html>
```

### JS的同步和异步

- 同步：程序执行顺序和代码顺序一致
- 异步：在做一件事的同时做另一件事
- 同步任务：放到主线程执行栈
- 异步任务（回调函数），放在消息队列：
  - 普通事件
  - 资源加载
  - 定时器

#### 执行机制

- 先执行执行栈的同步任务
- 异步任务放入任务队列
- 所有同步任务执行完成后，系统按次序读取任务队列里的异步任务，然后异步任务结束等待状态，进入执行栈，开始执行

### location对象

| 属性              | 返回值                 |
| ----------------- | ---------------------- |
| location.herf     | 整个URL                |
| location.host     | 域名                   |
| location.port     | 端口，如果未填写返回空 |
| location.pathname | 路径                   |
| location.search   | 查询参数               |
| location.hash     | 锚点                   |

案例：5秒后跳转到首页

```html
        <script>
            setTimeout(function(){
                location.href = "https://google.com";
            }, 5000);
        </script>
```

| 方法               | 返回值                                       |
| ------------------ | -------------------------------------------- |
| location.assign()  | 和href一样，跳转页面，也称重定向             |
| location.replace() | 替换当前页面，因为不记录历史，所以不能后退   |
| location.reload()  | 重新加载页面，如果参数为true，则强制重载页面 |

### navigator对象

包含浏览器相关信息，可获得浏览器版本，终端，系统版本等

### history对象

| 方法      | 描述                   |
| --------- | ---------------------- |
| back()    | 前进                   |
| forward() | 后退                   |
| go()      | 参数为1则前进 -1则后退 |

### 元素偏移量

可以：

- 获得元素距离带有定位父元素的位置
- 获取元素自身大小
- 注意：返回的数值都不带单位

| 属性                 | 描述                                   |
| -------------------- | -------------------------------------- |
| element.offsetLeft   | 返回元素相对带有定位的父元素的距离     |
| element.offsetTop    | 返回元素相对带有定位的父元素的距离     |
| element.offsetWidth  | 返回自身包括padding 边框，内容区的宽度 |
| element.offsetHeight | 返回自身包括padding 边框，内容区的高度 |

案例：获取鼠标在元素中的位置

```html
<html>
    <body>
        <div id="box"></div>
        <style>
            #box {
                margin: 0;
                width: 100px;
                height: 100px;
                background-color: pink;
                top: 300px;
                left: 300px;
            }
        </style>
    </body>
    <script>
        var ele = document.querySelector("#box")
        ele.addEventListener("click", function(e) {
            var x = e.pageX - this.offsetLeft;
            var y = e.pageY - this.offsetTop;
            ele.innerHTML = "X: " + x + " Y: " + y;
        })

    </script>
</html>
```

### jQuery

#### 引入

在页面中引入

```html
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
```

#### 入口函数

```js
$(function () {
    ....
}) //当页面加载完成时的入口
```

#### 顶级对象

$ JQuery时jq的顶级对象

但是一般情况下为了方便，都写$

$时jQuery的顶级对象，相当于原生js的windows，把元素利用$封装成jQuery对象，就可以利用jQuery的方法

#### jQuery对象和DOM对象

- DOM对象：使用原生DOM获取的对象
- jQuery对象：使用jQuery获取的u
- jQuery对象的本质是用$对DOM对象封装
- DOM转jQuery：$('video') $(DOM对象)
- jQuery转DOM：$('div').get[]

#### 选择器

```javascript
$('') //里面写css选择器即可
```

#### 筛选选择器

| 语法       | 用法          | 描述                                   |
| ---------- | ------------- | -------------------------------------- |
| :first     | $('li:first') | 获取第一个li元素                       |
| :last      |               | 获取最后一个li元素                     |
| :eq(index) |               | 选择获取到的元素中第二个元素           |
| :odd       |               | 从获取到的元素中选择索引号为奇数的元素 |
| :even      |               | 从获取到的元素中选择索引号为偶数的元素 |

```html
   <body>
        <div>1</div>
        <div>2</div>
        <div>3</div>
        <div>4</div>
    </body>
    <style>
    </style>
    <script>
        $('div:first').css('background-color', 'red');
    </script>
```

![image-20220420113236766](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220420113236766-16504255577431.png)

#### 排他思想

```css

```



# 后端

## 22.3.31

### 开发环境搭建

后端框架暂时决定使用express，webstorm可以一键创建express项目

![image-20220331215934803](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220331215934803.png)

然后会自动安装依赖

完成后 点击右上角的启动按钮

![image-20220331220206295](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220331220206295-16487353288671.png)

会在本地的3000端口启动开发服务器

用浏览器打开

可以看到 正常运行

![image-20220331220255238](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220331220255238-16487353768562.png)

### 创建路由

#### Get请求

```javascript
app.get('/get', (req, res) => {
  res.send("Fuck")
});
```

![image-20220331221457072](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220331221457072-16487360986613.png)

#### POST请求

```js
app.post('/fuck', (req, res) => {
  res.send(req.body)
});
```

![image-20220331221633549](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220331221633549-16487361953864.png)

#### 动态路由

```js
routes.get('/info/:id',(req,res)=>{
    res.send('您的id：'+req.params.id)
})
```

![image-20220401181538730](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220401181538730-16488081400731.png)

### 请求和响应

>**Request 对象** - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：

1. req.app：当callback为外部文件时，用req.app访问express的实例
2. req.baseUrl：获取路由当前安装的URL路径
3. req.body / req.cookies：获得「请求主体」/ Cookies
4. req.fresh / req.stale：判断请求是否还「新鲜」
5. **req.hostname / req.ip：获取主机名和IP地址**
6. req.originalUrl：获取原始请求URL
7. req.params：获取路由的parameters
8. req.path：获取请求路径
9. req.protocol：获取协议类型
10. req.query：获取URL的查询参数串
11. req.route：获取当前匹配的路由
12. req.subdomains：获取子域名
13. req.accepts()：检查可接受的请求的文档类型
14. req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码
15. req.get()：获取指定的HTTP请求头
16. req.is()：判断请求头Content-Type的MIME类型

**Response 对象** - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：

1. res.app：同req.app一样
2. res.append()：追加指定HTTP头
3. res.set()在res.append()后将重置之前设置的头
4. res.cookie(name，value [，option])：设置Cookie
5. opition: domain / expires / httpOnly / maxAge / path / secure / signed
6. res.clearCookie()：清除Cookie
7. res.download()：传送指定路径的文件
8. res.get()：返回指定的HTTP头
9. **res.json()：传送JSON响应**
10. res.jsonp()：传送JSONP响应
11. res.location()：只设置响应的Location HTTP头，不设置状态码或者close response
12. res.redirect()：设置响应的Location HTTP头，并且设置状态码302
13. res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。
14. res.send()：传送HTTP响应
15. res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Type
16. res.set()：设置HTTP头，传入object可以一次设置多个头
17. **res.status()：设置HTTP状态码**
18. res.type()：设置Content-Type的MIME类型

较为重要的已加粗显示

## 22.4.1

### 鉴权

首先需要安装express-session

```powershell
npm install express-session
```

然后引入它

```javascript
const session = require('express-session')
app.use(session({
  secret:'session-secret',
  saveUninitialized:true, //保存未初始化的session
  resave:true,
  cookie:{
    expires: new Date(Date.now() + 1000*60*60*24*7) //过期时间为7天c
      
  }

}))
```

使用示例：

Login.js

```javascript
const express = require('express')
const routes = express.Router()
routes.post('/', function (req, res) {
    if (req.body.user!=="admin"){
        res.json({
            "msg":"账号不存在"
        })
    } else{
        req.session.user =req.body.user
        res.json({
        code:0,
        msg:'登陆成功',
        account:req.body.name
    })}

    console.log('用户' + req.body.name + '登录')
    console.log(req.session.name)
})

module.exports = routes
```

Info.js

```javascript
const express = require('express')
const Router = express.Router()
Router.post('/',(req,res) => {
    if (!req.session.user){
        res.json({
            "msg":"未登录！"
        })
        req.session.time = 0;
    } else{
        console.log(req.session.user)
        if (req.session.time==null){
            req.session.time=0
        } else{
            req.session.time++
        }
        res.json({
            "msg":"欢",
            "user":req.session.user,
            "time":req.session.time
        })
        res.send(req.session.name)
    }

})
module.exports =Router
```

当已登录时请求![image-20220402105209481](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220402105209481-16488679312401.png)

## 22.4.3

#### Egg.js框架的使用

##### 安装

webstorm中没有一键创建egg.js的功能

所以需要手动创建

新建一个目录，打开cmd 输入

```powershell
npm init egg --type=simple
```

然后按几下enter即可

然后下载依赖

```powershell
npm i
```

就可以用webstorm打开了

##### 路由

按照egg.js的约定

所有的路由规则都放在/app/rounter.js内

```js
// router.js
module.exports = app => {
  const { router, controller } = app;
  router.get('/', controller.home.index);
  router.get('/info',controller.user.info)
};
```

## 22.4.4

### 数据库 ORM

#### 下载&安装

咱们的网站使用MongoDB，所以咱先把它下载下来

[下载链接]: https://www.mongodb.com/try/download/community

![image-20220404135413785](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220404135413785-16490516554351.png)

点击Download即可，下载安装时间可能较长，建议使用科学上网

然后需要在项目中安装mongoose

```shell
npm install mongoose --save
```

它是一个数据库ORM框架

然后在app.js中连接数据库

```javascript
mongoose.connect(
    'mongodb://localhost:27017/bornhub'
)
    .then(()=>console.log('connected'))
    .catch(e=>console.log(e)
)
```

##### 数据库建模

在/modules/User.js输入如下代码

```javascript
const mongoose = require("mongoose");
const {Schema} = mongoose
const UserSchema = new Schema({
    username:String,
    password:String
})
module.exports =mongoose.model('User',UserSchema)
```

其中，最后一行的‘User’就是数据库中文档名称

#### 插入数据

```javascript
const express = require('express');
const  Router = express.Router()
const User = require('../modules/User')
Router.post('/',async (req, res) => {
    const user = new User({
        username:req.body.username,
        password:req.body.password
    })
    user.save()
        .then(data =>{
            res.json(data)
        })
    //user.save().then(() => console.log('meow'));
})

module.exports =Router
```

####  查找数据

```javascript
const express = require('express')
const routes = express.Router()
const User = require('../modules/User')
routes.post('/', async (req, res) => {
    //res.json({})
    try {
        const data = await User.findOne()
        res.json(data.passwordd)
        //console.log(data)
    } catch (e) {
        console.error(e)
    }
})
module.exports = routes
```

注意 find函数前要加await 不然会报错

花了一下午才找到原因

findOne方法返回的是一个JSON对象

所以

```js
console.log(data.get('password'))
```

> 参考https://nodejs.dovov.com/mongoose-mongodb-11.html
>
> 你可以使用`findOne`而不是`find` 。 `findOne`将返回一个匹配你的查询的对象，而不是一个数组。

#### JSON相关操作

##### JSON转字符串

```java
const json = '{"result":true, "count":42}';
const obj = JSON.parse(json);

console.log(obj.count);


console.log(obj.result);

```

##### 字符串转JSON

```javascript
console.log(JSON.stringify({ x: 5, y: 6 }));


console.log(JSON.stringify([new Number(3), new String('false'), new Boolean(false)]));


console.log(JSON.stringify({ x: [10, undefined, function(){}, Symbol('')] }));


console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// expected output: ""2006-01-02T15:04:05.000Z""
```

# React

## 22.5.19 

### Hello React

```html
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>

</head>

<body>
    <script type="text/babel">
        //创建虚拟DOM
        const dom = <h1>Hello World</h1>

        //渲染虚拟DOM
        ReactDOM.render(dom, document.getElementById('root'));
    </script>
    <div id="root"></div>
</body>

</html>
```

![image-20220519223414936](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20220519223414936.png)

注意引入三个依赖的顺序，否则会报错

### 虚拟DOM创建方式

- 使用原生JS创建容器（不用）
- 使用jsx创建容器

```js
        //创建虚拟DOM
        const dom = <h1>使用原生jx创建容器</h1>
        const dom1 = React.createElement('h1', null, '使用jsx创建容器')


        //渲染虚拟DOM
        ReactDOM.render(dom, document.getElementById('root'));
```

## 22.5.21

### JSX语法

- 本质是React.createElement()的语法糖
- 全程：JavaScript XML



- 定义虚拟DOM，不需要写引号
- 标签中引入js表达式，需要用{}
- 标签类目指定不要用“class” 用className，因为class在ES6是关键字
- 内联样式要用键值对的形式
- 不能用多个根标签
- 标签必须闭合
- 标签首字母若大写开头，则渲染组件，若是小写字母，则渲染为html同名元素
- 只能写表达式

```jsx
        const id = 'id'
        const dom = 
        <div style={{"color":"green"}}>
            <h1 id={id} className='name'>使用jsx创建容器</h1>
            <input></input>
        </div>
```

![image-20220521163340215](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220521163340215.png)

 ### stats

复杂组件：有状态的组件就是复杂组件

#### 初始化

```JSX
        class Weather extends React.Component {
            constructor(props) {
                super(props);
                this.state = {
                    city: '北京'
                }
            }
            render(){
                return <h1>城市：{this.state.city}</h1>
            }
        }


        //渲染虚拟DOM
        ReactDOM.render(<Weather/>, document.getElementById('root'));
```

![image-20220521213313156](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220521213313156.png)

#### 修改状态

不能直接修改state的值，要使用React内置的API this.setState(),且会合并state，不是完全替换

```js
            changeWeather() {
                this.setState({
                    isHot: !this.state.isHot
                })
                console.log(this.state.isHot)
        }
```

#### 简写方式

```jsx
        class Weather extends React.Component {
            state = {
                isHot:true
            }
            changeWeather = () => {
                this.setState({
                    isHot: !this.state.isHot
                })}
             render(){
                return <h1 onClick={this.changeWeather}>天气：{this.state.isHot?"炎热":"凉爽"}</h1>
            }
        }
```

#### 总结

- state是组件对象最重要的属性，值为对象，{key:value}
- 组件被成为状态机通过更新组件state来更新页面
- 组件中render方法的this为组件实例对象
- 组件中自定义方法的this欸undefined解决方法：
  - 使用箭头函数
  - 强制绑定



### 事件绑定

```jsx
        class Weather extends React.Component {
            render(){
                return <h1 onClick={this.click}>点击</h1>
            }
        }
        function click() {
            console.log('clicked');
        }
```

和原生类似。注意，onClick后的函数名不要写括号，否则会立即执行

### props

```jsx
       class Person extends React.Component {
             render(){
                return <h1>年龄：{parseInt(this.props.age)+1}</h1>

            }
           ReactDOM.render(<Person age='19'/>, document.getElementById('2'));
```

![image-20220522130512529](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220522130512529.png)

### ref

用来标记一个标签

```jsx
        class MyCompoent extends React.Component {
             call = ()=>{
                alert(this.refs.input.value)
            }
            render() {
                return <div>
                    <input ref='input' type='text' onBlur={this.call}/>
                    </div>

        }
    }
```

![image-20220522162747539](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220522162747539.png)

#### createRef

```jsx
        class Input extends React.Component {
            myRef = React.createRef();
            call = () => {
                console.log(this.myRef.current)
            }
            render() {
                return <div>
                    <input ref={this.myRef} type='text' onBlur={this.call} />
                    </div>

            }

        }
```

![image-20220603212050812](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20220603212050812.png)

该容器只能存放一个元素

如果给两个元素相同的ref，则后一个会覆盖前一个

## 22.6.17

### axios发送http请求

先引入axios

```shell
npm install axios
```

```js
import axios from "axios";
```

axios()传入一个对象

```js
  var data = axios.get('http://localhost:4000',{

  }).then((response) => {
    console.log(response.data);
  })
```

## 22.7.17

### React-Router

npm安装

```shell
npm i react-router
```

```js
                    <Routes>
                        <Route
                            path="/"
                            element={<Navigate to="/index" replace/>}
                        />
                        <Route path="/video" element={<VideoPage/>}/>

                        <Route path="/user" element={<UserPage/>}/>
                        <Route path="/index" element={<IndexPage/>}/>
                    </Routes>
```

在index.js包上

```jsx
  <React.StrictMode>
    <BrowserRouter >
    <App />
    </BrowserRouter>
  </React.StrictMode>
```

## 22.8.5

### 函数式组件

函数组件是以函数的方式定义的组件

```jsx
    function Demo() {
        return <h1>Hello World</h1>;
    }
    ReactDOM.render(<Demo />, document.querySelector('#root'));
```

注意函数名首字母大写，在render的第一个参数要加html的尖括号

函数不是自己调用的，而是由React调用的

函数内的this为undefined

### 类的知识

#### 类的定义

```js
    class Person {
        
    }
```

#### 构造器

```jsx
        constructor(name, age, grade) {
            this.name = name;
            this.age = age;
            this.grade = grade
        }
```

```js
    class Person {
        constructor(name, age) {
            this.name = name;
            this.age = age;
        }
        speak() {
            console.log(`${this.name} is ${this.age} years old.`);
        }

    }
    class Student extends Person {
        constructor(name, age, grade) {
            super(name,age);
            this.grade = grade
        }
        study() {
            console.log(`${this.name} is ${this.age} years old and is in grade ${this.grade}.`);
        }
    }
```

### 类式组件

顾名思义，就是以类的形式定义的组件

```jsx
  class Demo extends React.Component {
        render() {
            return (
                <h1>Demo</h1>
            )
        }
    } {
        render() {
            return (
                <h1>Demo</h1>
            )
        }
    }
```

类式组件必须继承React.Component

且必须有render方法，且有返回值

render中的this是组件实例

## 22.8.6

### 事件绑定

### 类中方法的this指向

```js
        constructor(props) {
            super(props);
            this.state = {
                isHot : true
            }
            this.changeWeather = this.changeWeather.bind(this)
        }
```

### state

state表示react组件的状态

在类的构造方法中指定

```js
            this.state = {
                isHot : true
            }
```

注意，如需修改state，不能直接修改，需要使用React的API 

setState（）用法：

```js
this.setState({isHot: !isHot})
```

构造方法调用一次

render方法调用n+1次



state的简写方法

```jsx
        state = {
            isHot : true
        }
        changeWeather =  () => {
            const isHot = this.state.isHot
            this.setState({isHot: !isHot})
        }
```

### props

## 22.8.7 

### 组件通信

安装：

```shell	
npm i pubsub-js
```

消息的订阅

```js
var mySubscriber = function (msg, data) {
    console.log( msg, data );
};
var token = PubSub.subscribe('MY TOPIC', mySubscriber);
```

当有消息发布时，就会执行mySubscriber函数

消息的发布

```js
PubSub.publish('MY TOPIC', 'hello world!');
```

### github搜索案例

效果：![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//img/20220808140112.png)

使用：

- React
- PubSub.js
- MUI

组件划分：![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//img/20220808140254.png)



![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//img/20220808140313.png)

Header

```jsx
            <div>
                <h1>Search Github Users</h1>
                <TextField id="outlined-basic" ref={'a'} label="Outlined" variant="outlined" onKeyDown={(e)=> {
                    if (e.keyCode === 13) {
                        const value = this.refs.a.value;
                        axios.get(`https://api.github.com/search/users?q=${value}`).then(res => {
                            PubSub.publish('event', res.data.items);
                        })
                    }
                }}/>
            </div>
```

这里定义一个搜索框，当按下回车时向github发送请求，并发布消息，内容是github返回的数据

UserContainer

```jsx
    state = {
        shouldShow:false,
        data:{}
    }
    componentDidMount() {

          PubSub.subscribe('event', (msg, data) => {
            this.setState({
                shouldShow: true,
                data: data
            })
        });
    }
    componentWillUnmount() {
        PubSub.unsubscribe('event');
    }


    render() {
        console.log(this.state.shouldShow)
        return (
            <div id={'container'}>
                {
                        this.state.shouldShow ? this.state.data.map((item,index) => {
                            return <User name={item.login} image={item.avatar_url} key={index}/>
                        }) : <div/>
                }
            </div>
        );
    }
```



在组件挂载时订阅消息

当消息发布时，把数据放到state中

state的变化触发页面更新

然后遍历渲染组件即可

## 22.8.9

### Hooks

Hooks是React在16.8版本新推出的特征，可以在函数组件中使用state

#### 三个常用hooks

- state hook ：React.useState()
- Effect Hook : React.useEffect
- Ref Hook : React.useRef()

#### State Hook

```jsx
const [count,setCount] = React.useState(0)
```

## 22.10.4

### css模块

使用方法

- 创建xxx.module.css
- 引入xxx.module.css
- 通过classes来设置类

用于防止类名冲突

# UWP

## 22.10.2

### 配置开发环境

下载Visual Studio

https://visualstudio.microsoft.com/zh-hans/vs/

![image-20221002155541252](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//img/image-20221002155541252.png)

打开后选择**通用WIindows平台开发**

![image-20221002155945436](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//img/image-20221002155945436.png)

然后就可以新建项目了

![image-20221002160011013](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//img/image-20221002160011013.png)

### 常见控件

控件 可以理解为html

uwp应用使用xaml来布局

类似于xml

```xaml
<Page
    x:Class="App1.MainPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:App1"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="Gray"
    >

    <StackPanel
        Margin="50"
        Orientation="Horizontal"
        >
        <TextBlock Text="114514191810"></TextBlock>
        <TextBlock Text="114514191810"></TextBlock>
        <TextBlock Text="114514191810"></TextBlock>
        <TextBlock Text="114514191810"></TextBlock>
        <TextBlock Text="114514191810"></TextBlock>
        <TextBox></TextBox>
    </StackPanel>
</Page>
```

- TextBlock 文字

  | 属性         | 作用                                |
  | ------------ | ----------------------------------- |
  | Text         | 显示的文字                          |
  | ForeGround   | 字体颜色                            |
  | FontSize     | 字体大小                            |
  | FontWeight   | 字体粗细                            |
  | TextWrapping | 控制是否换行 取值为“Warp"或"NoWarp" |
  
  

- TextBox 输入框

  | 属性                  | 作用           |
  | --------------------- | -------------- |
  | PlaceholderText       | 占位文字       |
  | PlaceholderForeground | 占位文字的颜色 |


- Button 按钮

  | 属性       | 作用             |
  | ---------- | ---------------- |
  | Context    | 按钮上的文字     |
  | ForeGround | 按钮上的文字颜色 |
  | Background | 背景颜色         |

  

效果：

![image-20221002171210124](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//img/image-20221002171210124.png)

# Golang

## 22.8.19

### 变量声明

第一种

```go
func main() {
	var a int
	a = 20
	fmt.Println(a)
}
```

第二种

```go
var a int = 20
```

第三种

```go
	var c = 20
	fmt.Println(c)
```

第四种

```go
	c:=114514
	fmt.Println(c)
```

第五种

```go
func main() {
	var (
		a = 1
		b = 2
	)
	fmt.Println(a, b)
}
```

### 数组

数组是有固定长度的特定类型元素组成的序列

```go
	var arr [5]int
	arr[0] = 1
	arr[3] = 2
	fmt.Println(arr)
```

#### 遍历

```go
	var arr = [5]int{1, 2, 3, 4, 5}
	for index, value := range arr {
		fmt.Println(index,value)
	}
```

### 切片

```go
	var arr = []int{1, 2, 3, 4, 5}
	fmt.Println(arr)
```

和数组的不同在于，不需要指定长度

### Map

map是散列表的无序引用

```go
	var a=  map[string]string{
		"key1": "value1",
		"key2": "value2",
		"key3": "value3",
		"key4": "value4",
	}
	fmt.Println(a)
```

添加/修改元素

```go
	a["key114514"] = "value1919810"
	a["key1"] = "value2"
	fmt.Println(a)
```

删除

```go
	delete(a, "key2")
```

第一个参数是Map，第二个是Key

判断是否存在

```go
value,ok:=a["key5"]
```

如果只有一个参数，得到的是这个Key的值，Key不存在的话返回空

如果两个参数，第一个是Key的值，第二个是是否存在的布尔值

遍历

```go
	for key,value :=range a {
		fmt.Println(key,value)
	}
```

### 指针

指针也是一种类型，称之为指针变量，指针变量的类型为*Type

最大的特点就是存储了某个变量的实际位置，通过记录变量的地址实现对变量的间接操作

## 22.12.28

### 配置环境

```bash
choco install golang
```

然后找个空文件夹

```
go mod init name
```

然后用vscode打开

新建一个后缀为.go的文件

```go
package main
import (
	"fmt"
)
func main()  {
	var s string = "111"
	fmt.Println(s)
}
```

![image-20221228141759325](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20221228141759325.png)

### 定义变量

```go
var s  = "111" //自动推断
var s string = "111" //定义时指定类型
s:="111"   //适用于函数内
var a,b = 1,"1"  //一次声明多个变量

	var (
		pi = 1
		p = 2
	) //一次定义多个变量

```

### 常量

基本同变量，只是var变成const，定义后不可修改

### 字符串操作

常用操作

| 方法              | 作用               |
| ----------------- | ------------------ |
| len()             | 求长度             |
| strings.Contains  | 是否包含字串       |
| strings.split()   | 分割字符串         |
| strings.HasSuffix | 判断是否有指定前缀 |

```go
	fmt.Println(strings.Contains(a, "11"))
	fmt.Println(strings.Split(a, "2"))
	fmt.Println(strings.HasSuffix(a, "11"))
```

输出：

true
[111 11]
true   

### 数组

```go
    var arr1 = [5]int{1, 2, 3, 4, 5}
    var arr2 = [...]int{1, 2, 3, 4, 5, 6}
```

遍历

```go
	var a = [5]int{5, 4, 11, 325}
	for i := 0; i < len(a); i++ {
		fmt.Println(a[i])
	}
```

作为函数参数：

```go
func sum(a []int) int {
	var s = 0
	for i := 0; i < len(a); i++ {
		s = s + a[i]
	}
	return s
}
func main() {
	var a = []int{5, 4, 11, 325}
	print(sum(a))
}
```

### Map

创建

```go
var m = make[map[string]int]
```

map的方括号内写key的类型，make方括号内些值的类型

遍历

```go
	for k, v := range m {
		fmt.Println(k, v)
	}
```



判断是否存在key

value, ok := map[key]

如果存在，ok为true，value为key对应的value

如果不存在，ok为false，value为0



删除key

```go
	m := make(map[string]int)
	m["114"] = 514
	m["1919"] = 810
	fmt.Println(m)
	delete(m, "114")
	fmt.Println(m)

/*输出
	map[114:514 1919:810]
	map[1919:810]
*/

```

## 22.12.29

### http请求

```go
	var resp, _ = http.Get("https://api.lolicon.app/setu/v2")
	defer resp.Body.Close() //使用玩后必须关闭
	all, _ := ioutil.ReadAll(resp.Body)
	fmt.Println(string(all))
```

输出：![image-20221229205148690](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20221229205148690.png)

### defer关键字

在defer语句的外层函数返回之前系统会执行该延迟函数，用于处理文件关闭等

```go
	defer fmt.Println("B")
	fmt.Println("A")
```

结果是先输出A再输出B

### 文件相关

```go
	fmt.Println("输入一段字符串")
	bytes := []byte("")
	fmt.Scanln(&bytes)
	ioutil.WriteFile("C:\\Users\\zhang\\Desktop\\gO.txt", bytes, 0666)
	content, _ := ioutil.ReadFile("C:\\Users\\zhang\\Desktop\\gO.txt")
	fmt.Println(string(content))
```



### JSON

```go
type AutoGenerated struct {
	Error string `json:"error"`
	Data  []Data `json:"data"`
}
type Urls struct {
	Original string `json:"original"`
}
type Data struct {
	Pid        int      `json:"pid"`
	P          int      `json:"p"`
	UID        int      `json:"uid"`
	Title      string   `json:"title"`
	Author     string   `json:"author"`
	R18        bool     `json:"r18"`
	Width      int      `json:"width"`
	Height     int      `json:"height"`
	Tags       []string `json:"tags"`
	Ext        string   `json:"ext"`
	AiType     int      `json:"aiType"`
	UploadDate int64    `json:"uploadDate"`
	Urls       Urls     `json:"urls"`
}

func main() {
	var resp, _ = http.Get("https://api.lolicon.app/setu/v2?r18=true")
	defer resp.Body.Close()
	all, _ := ioutil.ReadAll(resp.Body)
	fmt.Println(string(all))
	var d AutoGenerated
	json.Unmarshal(all, &d)
	fmt.Println("标题：" + d.Data[0].Title)
    fmt.Println("作者：" + d.Data[0].Author)
}
```

![image-20221230084824305](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20221230084824305.png)

其中 结构体可以用这个网站生成

https://oktools.net/json2go 如果结构比较复杂可能会出问题，可以用下面的

https://transform.tools/json-to-go

## 22.12.30

### 加解密

```go
	//生成md5
	sum := md5.Sum([]byte("114514")) //md5.sum函数需要一个byte数组的参数，返回十进制数组
	fmt.Printf("%x", sum) //转成16进制输出


	//base64
	var a = []byte("")
	fmt.Scanln(&a)
	toString := base64.StdEncoding.EncodeToString(a)
	fmt.Println(toString)
	
```



## 23.2.18

### 解析html

首先引入依赖

```go
import (
    "github.com/PuerkitoBio/goquery"
)
```

然后

```go
goquery.NewDocumentFromReader()
```

里面传入一个reader

# Android

## 23.4.8

### TextView

属性

- layout_width 组件宽度
- layout_height 组件高度
- text 文本内容
- background 背景颜色
- gravity 内容对齐方向

![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/20230408102835.png)

## 23.6.22

###  LinearLayout

```xml
    <LinearLayout android:layout_width="match_parent"
                  android:layout_height="match_parent"
                  android:orientation="vertical"
                  android:id="@+id/linear"
    >
        <LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal">
            <TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="1" android:width="30dp" android:height="30dp" android:layout_margin="10dp"/>
            <TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="2" android:width="30dp" android:height="30dp" android:layout_margin="10dp"/>
        </LinearLayout>
        <TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="3" android:width="30dp" android:height="30dp" android:layout_margin="10dp"/>
        <TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="4" android:width="30dp" android:height="30dp" android:layout_margin="10dp"/>
    </LinearLayout>
```

## 23.6.23

### RelativeLayout

相对布局



![image-20230623091509555](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20230623091509555.png)

```xml
    <RelativeLayout android:layout_width="match_parent" android:layout_height="match_parent" android:layout_margin="15dp">
        <com.google.android.material.card.MaterialCardView android:layout_width="match_parent" android:layout_height="45dp" android:layout_centerInParent="true" android:background="@color/cardview_light_background">
            <TextView android:layout_width="match_parent" android:layout_height="match_parent" android:text="java.lang.NullPointExcpetion" android:layout_margin="5dp"/>
        </com.google.android.material.card.MaterialCardView>
    </RelativeLayout>
```

![image-20230623111458124](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20230623111458124.png)

### GridLayout

网格布局支持多行多列的数据展示

## 23.7.1

###  ScrollView

滚动视图，

```xml
    <ScrollView android:layout_width="match_parent"
                android:layout_height="wrap_content"

    >
        <GridLayout
                android:layout_width="match_parent"
                android:orientation="vertical"
                android:id="@+id/linear"
                android:columnCount="2"
                android:layout_height="wrap_content">
        </GridLayout>
    </ScrollView>
```

用法就是把需要滚动的View放到ScrollView里的一个子视图里（注意不是直接放到ScrollView里，ScrollView只能包含一个子元素

<img src="https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgScreenshot_20230701-172802_AndroidStudy.png" alt="Screenshot_20230701-172802_AndroidStudy" style="zoom:50%;" />

### 按钮

```kotlin
        var button = Button(this)
        button.layoutParams = LinearLayout.LayoutParams(300,300)
        button.setOnClickListener {
            var alertDialogBuilder = MaterialAlertDialogBuilder(this).setTitle("Title").setMessage("Message")
            alertDialogBuilder.create().show()
            var imageView = ImageView(this)
            binding.linear.addView(imageView)
            Glide.with(this)
                .load(URL("https://www.bear962464.cn/wp-content/uploads/2019/08/19AFCBC33C6B0D0105305231EA771B1C-150x150.jpg"))
                .into(imageView)
            alertDialogBuilder.setNegativeButton("取消") { dialog, which ->
                Snackbar.make(binding.linear, "你点了取消", LENGTH_SHORT).show()
            }
        }
        binding.linear.addView(button)
```

<img src="https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgScreenshot_20230701-200300_AndroidStudy.png" alt="Screenshot_20230701-200300_AndroidStudy" style="zoom:33%;" />

### 案例：简易计算器

```kotlin
class Main0Activity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        val gridLayout = findViewById<GridLayout>(R.id.btnArea)
        val textArea = findViewById<LinearLayout>(R.id.textArea)
        val textView = TextView(this)
        textView.textSize = 24F
        textArea.addView(textView)
        for (i in 1..15) {
            val button = Button(this)
            button.textSize = 20F
            button.text = i.toString()

            if (i==10) {
                button.text = "+"
            }
            if (i == 11) {
                button.text = "-"
            }
            if (i == 12) {
                button.text = "*"
            }
            if (i == 13) {
                button.text = "/"
            }
            button.setOnClickListener {
                var builder = StringBuilder(textView.text)
                builder.append(button.text)
                textView.text = builder.toString()
            }
            if (i==14) {
                button.text = "清除"
                button.setOnClickListener {
                    textView.text = ""
                }

            }
            if (i==15) {
                button.text = "计算"
                button.setOnClickListener {
                    try {
                        textView.text = Parser.parse(textView.text.toString()).evaluate().toString()
                    } catch (e:Exception) {
                        MaterialAlertDialogBuilder(this).setMessage("表达式错误\n\n\n").create().show()
                    }
                }
            }

            gridLayout.addView(button)
        }

    }
}
```

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:id="@+id/linear"
        android:layout_height="wrap_content">
        tools:context=".Main0Activity">


    <LinearLayout
            android:layout_width="match_parent"
            android:orientation="horizontal"
            android:id="@+id/textArea"
            android:background="#808080"
            android:layout_weight="1"
            android:layout_height="200dp">

    </LinearLayout>

    <GridLayout
            android:layout_width="match_parent"
            android:columnCount="4"
            android:id="@+id/btnArea"
            android:layout_margin="13dp"
            android:layout_weight="1"
            android:layout_height="0dp">
    </GridLayout>
</LinearLayout>
```

![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//img20230701224743.png)

## 23.7.2

### Activity的跳转

跳转到其他activity：

```kotlin
startActivity(Intent(this,MainActivity2::class.java))
```

第一个参数是this，第二个是目标activity的class

返回：

```kotlin
finish()
```

结束了第二个activity，就回到了第一个activity

### 生命周期

![image-20230702084823728](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20230702084823728.png)

![image-20230702091124962](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20230702091124962.png)

### Intent

直接翻译 就是 意图，可以在各个Activity直接传递数据

- 传递数据

```kotlin
        materialButton.setOnClickListener {
            var intent = Intent(this, MainActivity2::class.java)
            var bundle = Bundle()
            bundle.putString("key","value")
            intent.putExtras(bundle)
            startActivity(intent)
        }
```

- 接收数据

  ```kotlin
          MaterialAlertDialogBuilder(this)
              .setMessage("接收到了：" + (intent.extras?.getString("key") ?: ""))
              .create().show()
  ```

  <img src="https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgScreenshot_20230702-103129_AndroidStudy.png" alt="Screenshot_20230702-103129_AndroidStudy" style="zoom:33%;" />

- 接收上一个Actvity返回的数据

  ```kotlin
          materialButton.setOnClickListener {
              var intent = Intent()
              var bundle = Bundle()
              bundle.putString("content","ok")
              intent.putExtras(bundle)
              setResult(Activity.RESULT_OK,intent)
              finish()
          }
  ```

  ```kotlin
          var launcher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
              // 在这里处理结果
              if (result.resultCode == Activity.RESULT_OK) {
                  val data: Intent? = result.data
                  // 处理结果数据
                  MaterialAlertDialogBuilder(this)
                      .setMessage("返回了：" + (result.data?.getStringExtra("content") ?: ""))
                      .create().show()
              }
          }
  		launcher.launch(intent)
  ```

  <img src="https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgScreenshot_20230702-111023_AndroidStudy.png" alt="Screenshot_20230702-111023_AndroidStudy" style="zoom:25%;" />

### EditText

可编辑的文本框

可以设置默认提示文本，最大长度，显示类型等

```kotlin
        binding.btn.setOnClickListener {
            var dialog = MaterialAlertDialogBuilder(this).setTitle("提示")
            if (binding.user.text.toString() == "admin" && binding.password.text.toString() == "admin") {
                dialog.setMessage("欢迎，admin")

            } else {
                dialog.setMessage("密码错误！")
            }
            dialog.create().show()
        }
```

```xml
    <EditText
            android:layout_width="match_parent"
            android:layout_height="80dp"
            android:id="@+id/password"
            android:maxLength="6"
            android:hint="请输入密码"
            android:inputType="textPassword"
            android:shadowRadius="4">

    </EditText>
```

<img src="https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgScreenshot_20230702-131341_AndroidStudy.png" alt="Screenshot_20230702-131341_AndroidStudy" style="zoom:25%;" />

- 监听焦点变化事件

  ```kotlin
          binding.password.setOnFocusChangeListener { view, hasFocus ->
              if (hasFocus) {
                  // 处理获取焦点的操作
  
                  // ...
              } else {
                  // 处理失去焦点的操作
                  if (binding.password.text.toString().length != 5) {
                      binding.password.requestFocus()
                  }
                  // ...
              }
          }
  ```

  

## 23.7.17

### Application

全局变量。

可以用于存放不便使用Intent传递的信息。

### ContentProvider

用于向其他应用共享自己的数据。



## 23.7.20

### Adapter ListView

```kotlin
package cn.pprocket.android

import android.os.Bundle
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.ListView
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.WindowInsetsCompat
import cn.pprocket.android.bean.User
import cn.pprocket.android.databinding.ActivityMainBinding
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.google.gson.Gson
import com.google.gson.JsonParser
import okhttp3.OkHttpClient
import okhttp3.Request
import java.lang.StringBuilder


class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding
    var okHttpClient = OkHttpClient()
    var gson = Gson()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        var listView = binding.listView
        binding.exitText.windowInsetsController?.show(WindowInsetsCompat.Type.ime())
        binding.listView.onItemClickListener = AdapterView.OnItemClickListener { parent, view, position, id ->
            Thread {
                var s =
                    okHttpClient.newCall(Request.Builder().url("https://api.github.com/users/${(listView.adapter.getItem(position) as User).userName}/repos").build())
                        .execute()
                        .body()
                        ?.string()
                var builder = StringBuilder()
                JsonParser.parseString(s).asJsonArray.forEach {
                    var name = it.asJsonObject["name"].asString
                    //var desc = it.asJsonObject["description"].asString
                    var lastUpdate = it.asJsonObject["updated_at"].asString
                    builder.append(name + "\n")
                    //builder.append(desc + "\n")
                    builder.append(lastUpdate + "\n")
                    builder.append( "\n\n")

                }
                runOnUiThread {
                    MaterialAlertDialogBuilder(this).setMessage(builder.toString()).create().show()
                }
            }.start()
         }
        binding.btn.setOnClickListener {
            Thread {
                var request = Request.Builder()
                    .url("https://api.github.com/search/users?q=${binding.exitText.text}")
                    .get()
                    .build()
                var string = okHttpClient.newCall(request).execute().body()?.string()
                var asJsonObject = JsonParser.parseString(string).asJsonObject
                var list = mutableListOf<User>()
                asJsonObject["items"].asJsonArray.forEach {
                    var user = User()
                    user.userName = it.asJsonObject["login"].asString
                    user.avatar = it.asJsonObject["avatar_url"].asString
                    list.add(user)
                }
                runOnUiThread {
                    var adapter = Adapter(this,list)
                    listView.adapter = adapter
                }

            }.start()
        }

    }

}
```

```java
package cn.pprocket.android;

import android.content.Context;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;
import cn.pprocket.android.bean.User;
import com.bumptech.glide.Glide;

import java.util.List;

public class Adapter extends BaseAdapter {
    public Context mContext;
    public List<User> user;
    public Adapter(Context context, List<User> userList) {
        this.mContext = context;
        this.user = userList;
    }

    @Override
    public int getCount() {
        return user.size();
    }

    @Override
    public Object getItem(int position) {
        return user.get(position);
    }

    @Override
    public long getItemId(int position) {
        return 0;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        View view = convertView;
        if (view == null) {
            view = LayoutInflater.from(mContext).inflate(R.layout.row, null);
        }
        TextView textView = view.findViewById(R.id.textView);
        ImageView imageView = view.findViewById(R.id.imageView);
        textView.setText(user.get(position).userName);
        Glide.with(parent)
                .load(user.get(position).avatar)
                .into(imageView);
        int margin = 16; // 边距大小，单位为dp
        int marginPx = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, margin, view.getResources().getDisplayMetrics());

        // 使用LinearLayout.LayoutParams设置边距
        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        layoutParams.setMargins(marginPx, marginPx, marginPx, marginPx);
        view.setLayoutParams(layoutParams);
        return view;
    }
}

```

<img src="https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgScreenshot_20230720-131247_AndroidStudy.png" alt="Screenshot_20230720-131247_AndroidStudy" style="zoom:33%;" />

Adapter，就是适配器，用于向一个View表示数据。

# Java

## Collections类的使用

- Collections.sort(List<T> list) 给List排序
- Collections.shuffle(List<T> list) 打乱List

```java
        List<Integer> list = new ArrayList<>();
        Random random = new Random();
        System.out.println("原内容： ");
        for (int i = 0;i<100;i++) {
            var r = random.nextInt(1919810);
            list.add(r);
            System.out.printf("%d\t",r);
        }

        Collections.sort(list);
        System.out.println("\n排序后： ");
        list.forEach(ele -> {
            System.out.printf("%d\t",ele);
        });
        System.out.println("\n打乱后： ");
        Collections.shuffle(list);
        list.forEach(ele -> {
            System.out.printf("%d\t",ele);
        });
```

![image-20230430221342483](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20230430221342483.png)

## 反射 注解

### 注解

```java
public @interface MyAnnotation {
    
}
```

这样就定义了一个注解。

### 反射

反射，就是在运行时 动态地调用方法，获取类、方法、字段的信息。

获取Class对象

```java
        Class clz1 = Date.class; // 通过类名.class获取
        Class clz2 = Class.forName("java.util.Date");// 通过全限定类名获取
        Date date = new Date();
        Class clz3 = date.getClass(); // 通过对象获取
```

Class对象表示一个类，同一个类在JVM里只有一个Class实例，所以不能直接new来获取。

```kotlin
        var start = System.currentTimeMillis()
        val clz = Player::class.java
        println("类加载器： ${clz.classLoader}")
        println("方法数量：${clz.methods.size}")
        println("第二个方法 : ${clz.methods[1].name}")
        println("构造器数量：${clz.constructors.size}")
        var constructor = clz.getConstructor(Int::class.java, String::class.java) //通过class对象获取构造器
        var newInstance = constructor.newInstance(20, "Steve") //通过构造器对象创建对象
        println(newInstance)
        println("health字段的值：${newInstance.health}") //通过class对象获取字段
        clz.fields[0].set(newInstance,30) //获取Filed对象，设置字段值，参数为对象实例和字段值
        println("health字段的值：${newInstance.health}")
        println("耗时：${System.currentTimeMillis()-start}ms")
```

![image-20230804213325450](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20230804213325450.png)

获取方法：

```kotlin
        var declaredMethod = clz.getDeclaredMethod("kill")
        declaredMethod.invoke(newInstance) //通过class对象获取方法，调用方法
```

![image-20230804214223437](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20230804214223437.png)

## 时间

### Date类

Date类里的大多数方法被标记为过时。

```java
    public static void main(String[] args) {
        Date data = new Date();
        System.out.println(data.getTime());
        System.out.println(data);
    }
```

![image-20230803184817500](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20230803184817500.png)

### Calendar

Calendar是一个功能更强大的日期类，而且Date类在JDK1.1时已经弃用

```java
        Calendar instance = Calendar.getInstance(); //获取实例
        instance.set(2021, Calendar.SEPTEMBER, 1, 0, 0, 0); // 设置
        instance.add(Calendar.YEAR, 1); //添加
        System.out.println(instance.get(Calendar.YEAR));
        System.out.println(instance.get(Calendar.MONTH)+1);
        System.out.println(instance.get(Calendar.DAY_OF_MONTH));
        System.out.println(instance.get(Calendar.HOUR_OF_DAY));
        System.out.println(instance.get(Calendar.MINUTE));
        System.out.println(instance.get(Calendar.SECOND));
        System.out.println(instance.getTimeZone().getDisplayName());
        System.out.println(instance.getTimeZone().getID());
```

注意，获取月份的时候要+1

![image-20230804102733652](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20230804102733652.png)

### SimpleDataFormater

用于把字符串解析为日期 把日期按特定的格式转为字符串

```java
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat();
        simpleDateFormat.applyPattern("yyyy-MM-dd HH:mm:ss");
        System.out.println(simpleDateFormat.format(new Date()));
        System.out.println(simpleDateFormat.parse("2023-08-04 10:51:09"));
```

![image-20230804105235564](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20230804105235564.png)

# Python

## 23.4.30

### 变量类型转换

- int(x) 把x转为一个int 然后返回
- str(x) 把x转为一个字符串然后返回
- float(x) 把x转为一个float然后返回

```python	
money = 50
print(type(money))
print(type(str(50)))
```

![image-20230430224518592](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20230430224518592.png)

### 标识符

变量，方法，类的名字都是标识符。

规则：

- 大小写敏感
- 不可使用关键字
- 不可以使用数字开头
- 可以使用字母，数字，下划线
- 不建议使用中文

### 运算符

| 运算符 | 描述   |
| ------ | ------ |
| +      | 加     |
| -      | 减     |
| *      | 乘     |
| /      | 除     |
| //     | 取整数 |
| %      | 取余   |
| **     | 对数   |

```python
print(50+50)
print(50-40)
print(50*5)
print(50/5)
print(50%4)
print(10**2)
print(52//3)
```

![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/20230501100751.png)

## 23.5.1

### 字符串

#### 定义

- 单引号 ‘str’
- 双引号 “str”
- 三引号 “”“str”“”

```python
str1 = 'str'
str2 = "str"
str3 = """str"""
str4 = "'str'"
str5 = '"str"'
print(str1)
print(str2)
print(str3)
print(str4)
print(str5)
```

![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/20230501101447.png)

#### 拼接

- 使用加号连接字符串

- 只能连接字符串

  ```python
  print("电话： " + str(114514))
  ```

![image-20230501101719499](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20230501101719499.png)

### if

```python
money = 3000
vip = True
if money > 4000:
    print("可以购买")
elif vip and money >= 4000*0.7:
    print("可以购买")
else:
    print("余额不足")

```

![image-20230501112408835](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20230501112408835.png)

猜数案例：

```python
import random

num = random.randint(0, 10)
time = 3
while True:
    if(time <= 0):
        print("机会用完了")
        break
    if(int(input()) == num):
        print("猜对了")
        break
    else:
        print("猜错了")
        time-=1
```

![image-20230501112915845](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20230501112915845.png)

### while

```python
i = 1
s = 0
while i<=10000:
    s+=i
    i+=1
print(s)
```

![image-20230501153807223](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20230501153807223.png)

### range

- range(10) 从0-9
- range(5,10) 从5-9
- range(1,10,2) 1 3 5 7 9

```python
for i in range(5,10):
    print(i)
print("\n\n")
for i in range(10):
    print(i)
print("\n\n")
for i in range(1,10,2):
    print(i)
print("\n\n")
```

九九乘法表

```python
for i in range(0,10):
    for j in range(1,i+1):
        print(f"{i} * {j} = {i*j}")
    print("\n")
```

![image-20230501160309959](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20230501160309959.png)

工资案例

![image-20230501161347847](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20230501161347847.png)

```python
import random
balance = 10000
for i in range(1,21):
    level = random.randint(1,10)
    if balance<=0:
        print("工资发完了")
    if level<=5:
        print(f" 员工 {i} 业绩{level} 小于5 不发工资")
    else:
        print(f"员工 {i} 发1000元工资，剩余 {balance}")
        balance-=1000
    
```

![image-20230501161412446](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com/img/image-20230501161412446.png)

### 函数

```python
def func(input):
    for i in range(1,input+1):
        for i in range(1,input+1):
            print('*',end="")
        print()
func(5)
```

input是传入参数，不需要写类型。

## 23.5.20

### 文件操作

```python
f  = open("test.js","r+",encoding="utf-8")
list = f.readlines(0)
for ele in list:
    print(ele)
```

## 24.4.28

### 数据容器

Python中有

- list 列表

- tuple 元素

- str 字符串

- set 集合

- dict 字典

 5种数据容器

#### 列表

- 允许重复
- 有序
- 可以存放不同类型的数据

```python
list  = ['Python','Javascript']
print(list)
print(list[0]) //通过下标访问元素，下标从0开始
print(list[1])
print(list[-2]) //表示倒数第二个元素
print(list.index('Javascript')) //获取Javascript元素所在的下标值 如果找不到，会ValueError
list[0] = 'Java' //把下标为0的位置的值改为Java
list.append('Kotlin') //在列表的尾部插入一个元素
list.extend(['C#','Goland','Rust']) //批量插入元素
del list[5] //删除元素
list.pop(4) //删除元素
list.remove("C#") //删除元素，从前到后搜索，只删除找到的第一个
list.clear() //清楚列表
print(len(list)) //列表元素个数

while index < len(list): //遍历列表
    print(f"{index} Element is {list[index]}")
    index = index + 1
for element in list:
    print(f"{element}")
```

#### 元组

```python
tuple  = (21,25,21,23,22,20)
print(tuple)
```

即不可变的列表

#### 字符串

```python
str = "192.168.0.1"
print(str.split(".")) //分割字符串

str = "Old"
print(str.replace("Old","New")) //替换字符串
```



# C++

## 23.7.24

### 文件读写

```cpp
#include <iostream>
#include "string"
#include "random"
#include "fstream"
using namespace std;
int main() {
    ifstream input(R"(C:\Users\zhang\CodeProject\CPPLearn\main.cpp)");
    string line;
    while (getline(input,line)) {
        cout<<line<<endl;
    }
}

```

![image-20230724105231795](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20230724105231795.png)

### 结构体

```cpp
    struct Student {
        string name;
        int age;

    };
    Student s = {"pprocket",18};
    cout<<s.age<<endl;
    cout<<s.name<<endl;
    s.age =114514;
    cout<<s.age<<endl;
}
```

![image-20230724110647835](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//imgimage-20230724110647835.png)

# MySQL

## 安装

这里介绍使用docker方式安装

命令行输入

```bash
docker pull mysql
```

容器的环境变量中，添加**MYSQL_ALLOW_EMPTY_PASSWORD**变量，表示允许空密码。

![](https://imgbed-1254007525.cos.ap-nanjing.myqcloud.com//img/20240331165609.png)

然后点run创建容器，创建好之后就可以连接数据库了。

![image-20240331174553627](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240331174553627.png)

刚刚没有设置密码，所以直接留空即可。

## 执行SQL语句

点击navicat中的**新建查询**![image-20240331175137929](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240331175137929.png)

打开了一个类似shell的窗口，在里面就可以输入SQL语句，比如![image-20240331175246517](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240331175246517.png)



## 创建表

输入

```mysql
create database user;
show databases;
```

![image-20240331180833347](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240331180833347.png)可以看到，users数据库被创建了，如果需要删除，只需输入

```mysql
DROP DATABASE users
```

要创建一张表，需要先选择一个数据库

```mysql
use website
```

表示选择website这个数据库

```mysql
CREATE TABLE USER (
	userName VARCHAR ( 100 ),
	coins INT,
	id INT
)
```

![image-20240331181547215](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240331181547215.png)

除了使用SQL语句创建表，也可以使用navicat以可视化的方式创建表，非常方便。

![image-20240331181735191](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240331181735191.png)

## CRUD

### 增

```mysql
INSERT INTO USER VALUES ("Steve",1,10);
```

表示向USER这张表插入一行数据，括号内的内容为每个字段的值，如果括号内的值和表的结构不完全一致，需要指定每个值的字段名。

```mysql
INSERT INTO USER (userName,coins)VALUES ("Alex",100);
```

然后查看刚刚插入的数据

```mysql
select * from USER
```

![image-20240331185957131](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240331185957131.png)

如果需要一次插入多条数据

```mysql
INSERT INTO USER (userName) values ("Notch"),("Him");
```

### 删

```mysql
delete FROM USER where userName = 'Steve';
```

### 改

```mysql
update USER set coins = 1000; //把所有用户的硬币改为1000
update USER set coins = 114514 where userName = "Steve" //把Steve的硬币改为114514
```

![image-20240331191001620](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240331191001620.png)

## 复杂语句

```mysql
select SUBSTR(name,1,1) ,count(*) from player group by SUBSTR(name,1,1) ORDER BY COUNT(*) DESC  limit 5;
```

统计所有玩家的姓氏及其数量，显示前五名。![image-20240331201041367](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240331201041367.png)

显示每个玩家与平均等级的差值

```mysql
select level,round(level-(select avg(level) from player)) from player;
```

![image-20240331201353456](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240331201353456.png)

## 

# Vue

## 模板语法

- 插值语法

  ```vue
      <div id="root">
          <h1>Hello,{{age}}</h1>
      </div>
  ```

  双大括号内写变量的名字，会取出vue实例内data的值

- v-bind

  ```js
  <a :href="url">Nav To Youtube</a>
  ```

  如果要在标签属性里使用插值，不能直接用双大括号，要在属性前加上冒号，然后属性的值为变量名的字符串

- v-on

  ```js
  <button v-on:click="show">Click to invoke the func</button>
  <button @click="show($event,Math.random())">Click to invoke the func</button> 
  // v-on:click可以简写成@click，如果需要传入参数，直接写出字符串形式
      const vm = new Vue({
          el: '#root',
          data: {
              age: 'pprocket',
              url:'https://youtube.com'
          },
          methods:{
              show() {
                  alert("触发了函数")
              }
          }
      })
  ```

  

  ## 24.5.27

  ###  计算属性

  当一个值是通过计算得到的，可以使用计算属性实现
  
  ```js
      const vm = new Vue({
          el: '#root',
          data: {
              first: '',
              last: ''
          },
          computed: {
              fullName: {
                  get() {
                      return this.first + this.last
                  }
              }
          }
      })
  ```

如果不需要setter，可以简写成

```js
    const vm = new Vue({
        el: '#root',
        data: {
            first: '',
            last: ''
        },
        computed: {
            fullName: {
                get() {
                    return this.first + this.last
                }
            }
        }
    })
```

效果

- ![1716780153021.png](https://img2.imgtp.com/2024/05/27/CGl7WtIa.png)



# JavaWeb
## 24.6.13-14

###  Socket
#### 创建服务端
创建一个Server

~~~kotlin
    val socket = ServerSocket(8080)
    socket.use {
        println("Server running on port ${socket.localPort}")
        while (true) {
            val socket = socket.accept()
            println("Client connected: ${socket.inetAddress.hostAddress}")
            println("Port : ${socket.port}")
            val input = socket.getInputStream()
            val output = socket.getOutputStream()

        }
    }
~~~

~~~kotlin
fun main() {
    val socket = Socket("localhost", 8080)
}
~~~

#### 传输数据

客户端通过对OutputStream写入数据实现传输数据

~~~kotlin
fun main() {
    val socket = Socket("localhost", 8080)
    socket.use {
        socket.getOutputStream().use {
            it.write("Hello Socket!".toByteArray())
        }
    }
}
~~~

在服务端，获取InputStream对象，然后拿到内容

~~~kotlin
fun main() {
    val socket = ServerSocket(8080)
    socket.use {
        println("Server running on port ${socket.localPort}")
        while (true) {
            val socket = socket.accept()
            println("Client connected: ${socket.inetAddress.hostAddress}")
            println("Port : ${socket.port}")
            val input = socket.getInputStream()
            println("Input stream is ${input.readAllBytes().decodeToString()}")

        }
    }
}
~~~

<img src="https://s2.loli.net/2024/06/13/QZrjdpU61WzPehS.png" alt="image.png" style="zoom:67%;" />

#### 传输文件

往OutputStream写入的东西都是字节数组，如果要传输文件，把文件的每一个字节丢进OutputStream就好了

Client

~~~kotlin
fun main() {
    val socket = Socket("localhost", 8080)
    socket.use {
        socket.getOutputStream().use {
            it.write(File("build.gradle.kts").readBytes())
        }
    }
}
~~~

Server

~~~kotlin
            val socket = socket.accept()
            println("Client connected: ${socket.inetAddress.hostAddress}")
            println("Port : ${socket.port}")
            val input = socket.getInputStream()
            input.use {
                var bytes = it.readAllBytes()
                var file = File(UUID.randomUUID().toString())
                file.createNewFile()
                file.writeBytes(bytes)
                println("File size : ${bytes.size}")

            }
~~~

![image.png](https://s2.loli.net/2024/06/14/983Oe4HCJBmnMQk.png)

成功接收到文件。

#### 实现HTTP服务器

~~~kotlin
fun main() {
    val socket = ServerSocket(8080)
    socket.use {
        println("Server running on port ${socket.localPort}")
        while (true) {
            val socket = socket.accept()
            println("Client connected: ${socket.inetAddress.hostAddress}")
            println("Port : ${socket.port}")
            val input = socket.getInputStream()
            BufferedReader(InputStreamReader(input)).use { obj ->
                while (true) {
                    val line = obj.readLine()
                    if (line.isEmpty()) {
                        break
                    }
                    println(line)
                }
                OutputStreamWriter(socket.getOutputStream()).use {
                    it.write("HTTP/1.1 200 OK\r\n")
                    it.write("Content-Type: text/plain\r\n")
                    it.write("Content-Length: ${"Message from serve\n".length}\r\n")
                    it.write("\r\n")
                    it.write("Message from server\n")
                    it.flush()
                }
            }

        }
    }
}
~~~

注意写入内容的代码要写在BufferedReader代码块内，否则Stream被关掉就会出问题。

![image.png](https://s2.loli.net/2024/06/14/pdgceRMHjxA75UK.png)

## 24.6.14

### JDBC

JDBC是Java和数据库交互的一种规范，是在java.sql包下的接口。

对应的数据库驱动，就是对JDBC的实现。

#### 引入依赖

在build.gradle.kts加入如下代码

~~~kotlin
dependencies {
    implementation("mysql:mysql-connector-java:8.0.33")
    testImplementation(kotlin("test"))
}
~~~

#### 连接数据库

下方的代码创建了一张表。

~~~kotlin
    DriverManager.getConnection("jdbc:mysql://38.47.111.77:3306/sheet","sheet","CiGBT7PnHbPJki4P").use { connection ->
        connection.createStatement().use { statement ->
            statement.execute("CREATE TABLE Students (userId INT PRIMARY KEY,userName VARCHAR(255),gender INT)")
        }
    }
~~~

#### CRUD

增

~~~kotlin
statement.execute("insert into Students values(1,'admin',0)")
~~~

查

~~~kotlin
            statement.executeQuery("select * from Students").use { resultSet ->
                while (resultSet.next()) {
                    println("User ID : " + resultSet.getString(1))
                    println("Username" + resultSet.getString(2))
                    println("Gender" + resultSet.getString(3))
                }
            }
~~~

executeQuery方法返回一个ResultSet对象，结果以行组织。

在循环中，resultSet.getString(1)表示获取在当前这一行中，第一列的数据。

![image.png](https://s2.loli.net/2024/06/14/E1dteFWnBKcpGjX.png)

改

~~~kotlin
        connection.createStatement().use { statement ->
            println("Line changed : " + statement.executeUpdate("update Students set userName = 'banned' where userId = 1"))
        }
~~~

删

~~~kotlin
println("Line changed : " + statement.executeUpdate("delete from Students where userId = 1"))
~~~

#### SQL注入

用户输入的数据被当作SQL语句的一部分。

~~~kotlin

fun main() {
    val username = "admin"
    val password = "114514' or '1' = '1"
    DriverManager.getConnection("jdbc:mysql://38.47.111.77:3306/sheet","sheet","CiGBT7PnHbPJki4P").use { connection ->
        connection.createStatement().use { statement ->
            statement.executeQuery("select * from students where username = '$username' and password = '$password'").use { resultSet ->
                while (resultSet.next()) {
                    println("Logged in as ${resultSet.getInt(1)}")
                }
            }
        }
    }
}
~~~

![image.png](https://s2.loli.net/2024/06/14/u8HgZX2dk5MO4oV.png)

成功登录。

#### PreparedStatement

PreparedStatement可防止SQL注入攻击，内部把引号进行了转义。

使用原先的方法，发现注入失败。

~~~kotlin
fun main() {
    val username = "admin"
    val password = "114514' or '1' = '1"
    DriverManager.getConnection("jdbc:mysql://38.47.111.77:3306/sheet","sheet","CiGBT7PnHbPJki4P").use { connection ->
        var prepareStatement = connection.prepareStatement("select * from students where username =? and password = ?")
        prepareStatement.setString(1, username)
        prepareStatement.setString(2, password)
        var query = prepareStatement.executeQuery()
        while (query.next()) {
            println("Login successfully")
        }
    }
}
~~~

## 24.6.15

### MyBatis

#### 连接数据库

~~~xml-dtd
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://38.47.111.77:3306/sheet"/>
                <property name="username" value="sheet"/>
                <property name="password" value="CiGBT7PnHbPJki4P"/>
            </dataSource>
        </environment>
    </environments>
</configuration>
~~~



需要先有一个配置文件，里面配置了jdbc驱动，url，账号和密码。

然后在代码里面连接。

~~~kotlin
fun main() {
    var factory = SqlSessionFactoryBuilder().build(FileInputStream(File("config.xml")))
    factory.openSession().use { session ->
        
    }
}
~~~

如果没有问题的话，程序会正常结束。

#### Mapper

创建如下的xml文件

~~~xml-dtd
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="ns">
    <select id="selectStudents" resultType="Student">
        select * from students
    </select>
</mapper>
~~~

一个mapper必须要有namespace属性。

select标签的id属性即为在代码里使用的id。resultType表示要映射成的类名。

select标签内写MySQL语句。

写完之后要在config.xml里声明这个mapper

~~~xml
    <mappers>
        <mapper url="file:mapper.xml"/>
    </mappers>
~~~

~~~kotlin
fun main() {
    var factory = SqlSessionFactoryBuilder().build(FileInputStream(File("config.xml")))
    factory.openSession().use { session ->
        var list = session.selectList<Student>("selectStudents")
        list.forEach {
            println(it)
        }
    }
}
~~~

![image-20240615125526271](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20240615125526271.png)

#### 绑定接口

定义一个接口

~~~java
import java.util.List;

public interface StudentMapper {
    List<Student> selectStudents();
}
~~~

selectStudents方法名就是mapper的id。

在上面的mapper.xml里面，把namespace设置为接口的类名。

mybatis会自动生成一个接口的实现类，通过getMapper方法获取。



~~~kotlin
    var factory = SqlSessionFactoryBuilder().build(FileInputStream(File("config.xml")))
    factory.openSession().use { session ->
        var mapper = session.getMapper(StudentMapper::class.java)
        mapper.selectStudents().forEach { student ->
            println(student)
        }
    }
~~~

#### 指定查询参数

在mapper.xml中，通过${}或者#{}传入参数，例如

~~~xml
    <select id="selectById" resultType="Student">
        select * from students where id = ${id}
    </select>
~~~

~~~java
Student selectById(int id);
~~~

#### 注解

使用注解定义查询语句可以省去创建xml mapper的麻烦

~~~kotlin
public interface StudentMapper {
    @Select("select * from students ")
    List<Student> selectStudents();

    @Select("select * from students where id='#{id}'")
    Student selectById(int id);

    @Insert("insert into students values(#{id},#{userName},#{password})")
    boolean addStudent(Student student);

    @Delete("delete from students where id=#{id}")
    boolean deleteById(int id);

    @Update("update students set password=#{arg1} where id=#{arg0}")
    int updatePassword(int id,String password);
}
~~~

## 24.6.16

### 图书管理系统

#### 创建表

~~~sql
create table borrow(sid int auto_increment key ,bookId int,userId int,borrowTime varchar(64), state boolean,backTime varchar(64))

create table books(sid int auto_increment key ,bookName varchar(32),state boolean);

create table users(sid int auto_increment key ,name varchar(32),gender varchar(2));
~~~

#### 创建Mapper

BookMapper.java

~~~java
public interface BookMapper {
    @Select("select * from books ")
    List<Book> selectBooks();

    @Select("select * from books where sid='#{id}'")
    Book selectById(int sid);

    @Insert("insert into books values(#{sid},#{bookName}) ")
    boolean addBook(Book book);

    @Delete("delete from books where sid=#{sid}")
    boolean deleteById(int sid);
}

~~~

BorrowMap.java

~~~java
public interface BorrowMap {
    @Select("select * from borrow")
    List<Borrow>  getBorrrow();

    @Select("select * from borrow where sid = #{sid}")
    Borrow getBorrowBySid(int sid);

    @Insert("insert into borrow value(#{sid},#{bookId},#{userId},#{borrowTime},#{state},#{returnTime})")
    int borrowBook(Borrow borrow);
}
public interface BorrowMap {
    @Select("select * from borrow")
    List<Borrow>  getBorrrow();

    @Select("select * from borrow where sid = #{sid}")
    Borrow getBorrowBySid(int sid);

    @Insert("insert into borrow value(#{sid},#{bookId},#{userId},#{borrowTime},#{state},#{returnTime})")
    int borrowBook(Borrow borrow);
}

~~~



UserMapper.java

~~~java
public interface UserMapper {
    @Select("select * from users ")
    List<User> selectStudents();

    @Select("select * from users where sid='#{id}'")
    User selectById(int sid);

    @Insert("insert into users values(#{sid},#{name},#{gender})")
    boolean addUser(User student);

    @Delete("delete from users where sid=#{id}")
    boolean deleteById(int id);
}
~~~



#### 添加数据

~~~kotlin
        userMapper.addUser(User(null,"Andy","M"))
        userMapper.addUser(User(null,"Bobby","M"))
        userMapper.addUser(User(null,"Davie","M"))
        userMapper.addUser(User(null,"Alice","F"))
        userMapper.addUser(User(null,"Blue","M"))
        userMapper.addUser(User(null,"Mike","M"))

        bookMapper.addBook(Book(null,"Java from enter to engineer"))
        bookMapper.addBook(Book(null,"English"))
        bookMapper.addBook(Book(null,"Math"))
        bookMapper.addBook(Book(null,"Physical"))
        bookMapper.addBook(Book(null,"Chemical"))
~~~

## 24.6.17

### Tomcat

#### 安装

tomcat官网：https://tomcat.apache.org/download-10.cgi

![image.png](https://s2.loli.net/2024/06/17/xWjqwhIFLUknE1c.png)
选择tar.gz格式

解压后放到一个文件夹内即可。

#### 创建项目

项目类型选择Jakarta

![image.png](https://s2.loli.net/2024/06/17/FOyZtb7sE3G6fCS.png)
Application这一栏，点击new，新建一个服务器，路径选择刚刚下载tomcat的地方

![image.png](https://s2.loli.net/2024/06/17/jtmpv3iscxkFSrM.png)

然后一路点击next即可。

### Servlet

#### 创建

通过实现Servlet接口来创建一个servlet

~~~java
@WebServlet("/info")
public class HelloServlet implements Servlet {

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {

    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {

    }

    @Override
    public String getServletInfo() {
        return "";
    }

    @Override
    public void destroy() {

    }
}
~~~

添加@WebServlet注解表示路径。

其中，init方法在这个servlet第一次被请求时调用一次。

service方法在每次请求时调用，在这里处理请求，编写逻辑。

destroy方法在tomcat服务器关闭时调用一次



此外还可以通过继承HttpServlet类来创建一个servlet

~~~java
@WebServlet("/info")
public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().write("<input></input>");
    }
}
~~~

此时访问这个接口，就可以看到对应的内容。

#### 获取参数

通过HttpServletRequest.getParameterMap方法获取。

~~~java
        req.getParameterMap().forEach((k, v) -> {
            log.info(k + " : " + Arrays.toString(v));
        });
~~~

#### 上传和下载

下方代码给浏览器返回一个图片。

设置正确的ContentType，然后往输出流里面写数据即可。

~~~java
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType("image/jpeg");
        ServletOutputStream out = resp.getOutputStream();
        InputStream in = getResourceAsStream("image.png");
        byte[] buffer = new byte[1024];
        int len;
        while ((len = in.read(buffer)) != -1) {
            out.write(buffer, 0, len);

        }
        in.close();
        out.close();

    }
    public InputStream getResourceAsStream(String path) {
        return this.getClass().getClassLoader().getResourceAsStream(path);
    }
~~~

![image.png](https://s2.loli.net/2024/06/17/o8R6B2dkibjzYh3.png)

#### 重定向

~~~java
resp.sendRedirect("second");
~~~

会响应http 302，并在header中添加location标头，浏览器会重定向到相应的链接。

## 24.6.18

### Session

用于在一个会话中存储数据。基于Cookie实现。

~~~java
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        HttpSession session = req.getSession();
        if (session.getAttribute("list") == null) {
            session.setAttribute("list", new ArrayList<>());
        }
        List<String> list = (List<String>) session.getAttribute("list");
        list.add(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));
        list.forEach(resp.getWriter()::println);
        session.setAttribute("list", list);
    }
~~~

上方的代码记录了一个用户每次访问的时间，并显示在页面上。

![image.png](https://s2.loli.net/2024/06/18/SobWZ2L3NcRK1dM.png)

![image.png](https://s2.loli.net/2024/06/18/sNa2OqCuYoyUJMT.png)
session会在浏览器关闭后失效。

Tomcat中，session默认在三十分钟后失效。

## 24.6.23

### AOP

即界面，可理解为hook，干预一个方法的执行。

需要引入aop的依赖

~~~java
implementation("org.springframework:spring-aspects:6.0.4")
~~~



配置类

~~~java
@Configuration
@ComponentScan(basePackages = "cn.pprocket")
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class MainConfiguration {

}
~~~

如果需要代理的类是一个接口的实现类，要指定proxyTargetClass为true

 AOP类

~~~java
@Aspect
@Component
public class SayAOP  {
    @Before("execution(* cn.pprocket.ArtStudent.sayHello())")
    public void invoke(JoinPoint joinPoint) {
        System.out.println("SayAOP");
        System.out.println(joinPoint.getSignature().getDeclaringType().getName());
    }
}

~~~

可以通过JoinPoint获取被hook方法的参数，修改返回值等。

### Mybatis

配置类

~~~java
@Configuration
@ComponentScan(basePackages = "cn.pprocket")
@EnableAspectJAutoProxy(proxyTargetClass = true)
@MapperScan("cn.pprocket.mapper")
public class MainConfiguration {
    @Bean
    public DataSource dataSource() {
        return new PooledDataSource("com.mysql.cj.jdbc.Driver", "jdbc:mysql://38.47.111.77:3306/sheet", "sheet", "CiGBT7PnHbPJki4P");

    }
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory() throws Exception {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource());
        return sqlSessionFactoryBean;
    }

}

~~~

即可让spring自动管理mapper，需要用的时候直接获取即可

~~~kotlin
fun main() {
    val context = AnnotationConfigApplicationContext(MainConfiguration::class.java)
    var bean = context.getBean(BookMapper::class.java)
    println(bean.findAll())
}
~~~

![image.png](https://s2.loli.net/2024/06/23/xQ5P3UfcDhbjqsk.png)

